<div style="font-weight: normal;">
	Пришла в мою, затуманенную черепно-мозговыми травмами и алкогольно-наркотическими веществами, голову идея сделать софт для получения данных синхронизации браузера Google Chrome, которым пользуются большинство трезвомыслящих людей. Хронические долбоебы сидят в 21м веке на Opera, придумывая непонятные аргументы вроде "она красненькая и с красивым стартовым экраном". IE - выбор тех, кому все равно, к 10й версии в майкрософте его отлично причесали, но попробуй теперь перебори этот стереотип шестерки. Firefox - для ностальгирующих по сотням тысяч плагинов, для анимешников, ненавидящих империализм и диктатуру Google, или же страдающих навязчивой идеей превращения браузера в почтовый клиент, чат, хлебопечку и цифровое влагалище.</div><div style="font-weight: normal;"><br></div><div style="font-weight: normal;"><b>UPD: </b>Synchromium теперь доступен для ваших айфончиков в <a href="http://itunes.apple.com/us/app/synchromium/id521738462?ls=1&amp;mt=8">iTunes</a>. Жалко 99 центов? Пиши мне - вышлю промокод.<br><br><b>UPD</b>: Необходимую сумму я заработал, синхромиум доступен for free для всех желающих. Тем более, с выходом Google Chrome на iOS актуальность программы утратилась.<br></div><div style="font-weight: normal;"><br></div><div><b>UPD</b>: Synchromium на <a href="http://my-chrome.ru/2012/05/synchromium-sinxronizaciya-google-chrome-v-vashem-iphone/" style="font-weight: normal;">my-chome.ru</a>&nbsp;и в их же&nbsp;<a href="http://vk.com/wall-22746204_50683" style="font-weight: normal;">vk</a>.&nbsp;</div>
<div style="font-weight: normal;">
	&nbsp;</div>
<div style="font-weight: normal;">
	Программа, разумеется, для телефонов марки iPhone, которые используют не только трезвомыслящие и идейные, но все кому не лень, создавая огромный потребительский рынок, готовый проглотить любое привлекательное предложение. Я сейчас про&nbsp;<a href="http://www.mindcollapse.com/blog/257.html">нормальные страны</a>, если что. Делал я эту небольшую утилиту под названием&nbsp;<a href="https://github.com/mindcollapse/Synchromium-iPhone">Synchromium</a>&nbsp;(ну чотко же, да? тут вам в названии и синхронизация, и хромиум) не столько для алчного желания наживы (после review обезьянками из эппла она появится в AppStore по смешной цене в 99 центов, о чем я сообщу в&nbsp;<a href="https://twitter.com/middlesizetit">уютненьком ласковом твиттере</a>, там же будет проведена раздача 40 промокодов для бесплатной загрузки), сколько для ознакомления с современным инструментарием разработки под iOS. Последний раз я занимался этим в те далекие времена, когда XCode был еще в третьей версии, iOS называлась iPhoneOS, а толпы индусо-китайцев еще не купили себе БУшный маки и не начали демпинговать цены своим ущербным предложением.</div>
<div style="font-weight: normal;">
	&nbsp;</div>
<div style="font-weight: normal;">
	Обычно я разбирался в способе передачи данных следующим образом: запускал&nbsp;<a href="http://mitmproxy.org/">mitmproxy</a>&nbsp;(незаменимая вещь, которая после установки своего корневого сертификата на целевую машину, реализует ssl interception&nbsp;<a href="http://mitmproxy.org/doc/ssl.html">оригинальным образом</a>&nbsp;- realtime генерацией своих самоподписных, но валидных сертификатов для всех https запросов), настраивал прокси сервер в виртуальной машине с Windows, запускал испытуемую программу и наблюдал за ее поведением. К счастью, в современном мире для большинства сервисов REST API в сочетании с JSON де-факто стал стандартом обмена информацией между клиентом и сервером. Но я забыл, что это же Google, йопта!&nbsp;<a href="http://www.youtube.com/watch?v=RnfXvPBV1dA">Paranoid Android</a>, как пели радиоголовые. Сложно описать, насколько сильным было мое разочарование, когда в привычном Answer body вместо ожидаемой каши из XML тегов или десятков скобок JSON я увидел бинарный нераспарсиваемый яд с вкраплением кучи base64 encoded строк и unicode мешанины. Это так же обидно, как и выиграть в национальной лотерее поездку на 5 дней в Крым, в частный сектор, за 7 километров от моря.</div>
<div style="font-weight: normal;">
	&nbsp;</div>
<div style="font-weight: normal;">
	На этом можно было махнуть на идею рукой, взять билет в Бангкок и пойти в гоу-гоу бар смотреть на бывшего мужика в коротенькой юбке и в топике, как бы странно это не звучало. К счастью, Google Chrome это Google Chromium на стероидах, который как бы опенсорсе со всеми вытекающими. Тут нужно отметить великолепное качество и логику организации кода в&nbsp;<a href="http://src.chromium.org/viewvc/chrome/">репозитарии</a>. Им зачитываешься как Википедией: начинаешь изучать код синхронизации данных, а через какое-то время уже смотришь на их враппер вокруг OpenSSL или на уровень абстракции NaCl. Но что-то я запизделся. Вкратце, в Google изобрели свой протокол обмена под названием&nbsp;<a href="http://code.google.com/p/protobuf/">Protocol Buffers</a>. Термин "протокол", правда, тут не подходит, скорее способ инкапсуляции данных, так как протобуфер в нашем случае работает поверх HTTP.&nbsp;</div>
<div style="font-weight: normal;">
	&nbsp;</div>
<div style="font-weight: normal;">
	Сама реализация напомнила мне такой себе ORM для API. В proto файле вы описываете интерфейс будущего объекта, а потом специальный транслятор-компилятор&nbsp;<a href="https://developers.google.com/protocol-buffers/docs/reference/python-generated">protoc</a>&nbsp;переводит эти файлы из родного формата и синтаксиса в классы на C++, Python, Java прямо "искаропки", либо в любой другой, поддерживаемый&nbsp;<a href="http://code.google.com/p/protobuf/wiki/ThirdPartyAddOns">неофициально</a>. Протосинтаксис достаточно богат, реализовано наследование, инкапсуляция, полиморфизм и прочие прелести OOD. Идея не нова (тот же&nbsp;<a href="http://thrift.apache.org/">Apache Thrift</a>), но охуенна в своем удобстве и простоте. По сути, описав весь протокол взаимодействия один раз, вы получаете готовый cross-language код ready for work. А еще этот способ призван обезопасить ваше API от посторонних глаз и пытливых умов, без proto файла практически нереально сформировать измененный запрос или разобрать ответ во что-то читаемое. Именно практически, ведь на теоретическом уровне&nbsp;<a href="http://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%BE_%D0%B1%D0%B5%D1%81%D0%BA%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D1%8B%D1%85_%D0%BE%D0%B1%D0%B5%D0%B7%D1%8C%D1%8F%D0%BD%D0%B0%D1%85">гипотетическая обезьяна</a>, ударяя пальцами по клавиатуре печатной машинки случайным образом, рано или поздно напечатает одну из пьес Шекспира. Но где вы видели таких обезьян? Современные писатели из РФ и Украины не в счет. Protocol Buffers - основная техническая причина, почему Google+ все еще не имеет сторонней реализации функции отправки сообщения. Мобильный клиент для обмена данными использует именно его.</div>
<div style="font-weight: normal;">
	&nbsp;</div>
<div style="font-weight: normal;">
	К моему счастью, для ObjectiveC существовала&nbsp;<a href="http://code.google.com/p/metasyntactic/wiki/ProtocolBuffers">unofficial реализация</a>&nbsp;протокола сравнительно достойного качества. Все&nbsp;<a href="http://src.chromium.org/viewvc/chrome/trunk/src/sync/protocol/">дескрипторы</a>&nbsp;были взяты из исходного кода Google Chromium и успешно&nbsp;<a href="https://github.com/mindcollapse/Synchromium-iPhone/tree/master/ChromeSync/ProtocolClasses">собрались</a>&nbsp;в .m и .h non-ARC файлы. Собрались, правда, не без проблем, результат пришлось немного редактировать вручную для устранения некоторых критических ошибок, которые сводились, как правило, к непонятному переназначению переменных и наслаивающимся областям видимости. Ну а дальше дело техники. Во многом мне помогла внутренняя страница Google Chrome доступная по адресу&nbsp;<a href="chrome://sync/">chrome://sync</a>. Много писать о самой реализации я не буду, чуть ниже вас ждет целый абзац о моих впечатлениях от XCode, iOS и еще один абзац с описанием проблемы, которую я впервые попробую решить с помощью читателей этого бложика.&nbsp;</div>
<div style="font-weight: normal;">
	&nbsp;</div>
<div style="font-weight: normal;">
	С самого начала для хранения данных я решил попробовать модный&nbsp;<a href="http://en.wikipedia.org/wiki/Core_Data">CoreData</a>&nbsp;- уровень абстракции от синтаксиса sqlite (не только, но в большинстве своем). Скажу сразу, я ни разу не ObjectiveC программист. Выучить синтаксис после всех тех языков, которые я знаю, проблемы не составило, но я никогда не смогу понять эту увлеченность объектами и порождение ненужных сущностей. Язык развивается, пытаясь избавиться от тяжелого наследия си с помощью блоков, нотификейшнов или нового <a href="http://joris.kluivers.nl/blog/2012/03/13/new-objectivec-literal-syntax/">синтаксиса конструкторов</a> для основных типов, но все еще выглядит крайне монструозно с этой кашей делегатов и оборачивания в классы всего того, что отлично помещалось и в примитивы. Так вот получилось и с CoreData. За призрачным удобством разметки схемы базы данных скрывается каша из координаторов, контекстов, фетчед-реквестов и прочих излишеств. Да, при правильном подходе все это офигенно интегрируется в инфраструктуру того же UITableView, но я, видимо, просто не достиг дзена. И именно поэтому использовал&nbsp;<a href="https://github.com/ccgus/fmdb">FMDB</a>&nbsp;- обертку над сишной sqlite3 библиотекой с raw sql request syntax. Все очень просто и со вкусом, а как легко интегрировалось в тот же TableView? Ну просто песня.</div>
<div style="font-weight: normal;">
	&nbsp;</div>
<div style="font-weight: normal;">
	Сам XCode изменился. Я бы не сказал, что в лучшую сторону, развитие движется в направлении, которое нам пытаются преподнести единоверным. Безусловно, ARC порадовал прожженную release-ами и dealloc-ами душу старого волка. Впрочем, возникли определенные трудности в понимании принципов его работы. У меня был UIViewController c всунутым в него UIWebView, вся эта красота показывалась пользователю через pushViewController сигнал UINavigationController-а. И вот, если вдруг пользователь открывал этот экран с вебвью и загружал в ней какой-то адрес, а потом, не дождавшись окончания загрузки, нажимал Back, то весь UIViewController деаллокался, но при этом, по окончанию загрузки, вебвью, который вроде как бы должен был умереть вместе с родителем, посылал уже мертвому папаше сигнал "пацантрэ, празднуем, я закончил грузить", что, естественно, приводило к падению всего в ERR_BAD_ACCESS. Это решилось отсылкой стоп-сигнала вебвью из viewWillDisappear, но кажется каким-то печальным недоразумением. Вероятней всего, имела место моя тупость, которая позволила сделать делегатом UIWebView объект, который этот вебвью и создал, но тем не менее.&nbsp;</div>
<div style="font-weight: normal;">
	&nbsp;</div>
<div style="font-weight: normal;">
	Полным факапом я считаю историю со Storyboard. Зачем это было сделано остается для меня загадкой. Возможно, редактирование интерфейса в XIB недостаточно тормозило. С одной стороны все стало как-то удобней и логичней (особенно в свете Static Cells, те же экраны настроек или формы входа можно теперь делать не вслепую в коде, а прямо в UI дизайнере), но с другой стороны я не вижу смысла в отображении всех экранов приложения, соединенных segue стрелками. Ну ладно, все это имело бы право на жизнь, если бы не жутчайшие лаги. После 20 разных контроллеров в одном Storyboard начинается покадровый цирк, а 8GB оперативной памяти категорически не хватает. И да, в 21 веке XCode все еще не может избавиться от детской болезни неадекватной организации проекта. Все просто валится скопом в одну папку, ваш покорный слуга потратил целый час, приводя <a href="https://github.com/mindcollapse/Synchromium-iPhone">код</a> в нормальный читаемый вид не только в IDE, но и в Finder-Explorer.&nbsp;</div>
<div style="font-weight: normal;">
	&nbsp;</div>
<div style="font-weight: normal;">
	Раз уж вы дочитали до самого конца, то самое время поговорить о чем-то интересном. Прежде всего, форкнуть или скачать код Synchromium&nbsp;<a href="https://github.com/mindcollapse/Synchromium-iPhone">вы можете на GitHub</a>. Я считаю, что большинство приложений для iOS должны быть opensource. Это не лишает разработчиков каких-то гиперприбылей, ведь для компиляции скачанных исходников не под iOS Simulator или хотя бы установки на свой девайс нужно покупать Developer License за 99 американских марок. А на jailbreak-нутый девайсах ваша программа и так рано или поздно появится в&nbsp;<a href="http://hackulo.us/wiki/Installous">Installous</a>-e.</div>
<div style="font-weight: normal;">
	&nbsp;</div>
<div style="font-weight: normal;">
	Впервые за всю историю существования этого блога, я прошу помощи и обещаю за нее денежное вознаграждение. Небольшое, но вы будете горды собой, прославлены в этом бложике и в самой программе. Чего уж там, я даже сделаю татуировку с&nbsp;<a href="http://cool4u.ru/kartinki/1241-uzhasnye-tatuirovki-detey.html">вашей фотографией</a>. Проблема состоит в следующем - в Google Chrome существует возможность cшифровать свои данные синхронизации. Сотрудниками Google был разработан собственной алгоритм (вас это еще удивляет?) под кодовым названием Nigori. По сути, это даже не алгоритм шифрования, а концепция обмена данными между облаком и устройством. Подробнее о нем&nbsp;<a href="http://www.links.org/files/nigori-protocol.html">можно прочитать</a>. И вот передо мной встала задача: как расшифровывать зашифрованные данные. Что может быть проще, когда под рукой есть отличные исходники Хромиума? Да, признаю, я беспробудно туп. Даже имея весь материал на руках, я не могу перенести его на платформу iOS и CommonCrypto фреймворк. Чуть ниже следует мое виденье алгоритма с ссылками на исходный код.</div>
<div style="font-weight: normal;">
	&nbsp;</div>
<div style="font-weight: normal;">
	Нас интересует файл&nbsp;<a href="http://code.google.com/searchframe#OAMlx_jo-ck/src/sync/util/nigori.cc&amp;exact_package=chromium&amp;q=nigori&amp;ct=rc&amp;cd=2&amp;sq=">nigori.cc</a>. Прежде всего, нужно обратить внимание на&nbsp;<a href="http://code.google.com/searchframe#OAMlx_jo-ck/src/sync/util/nigori.cc&amp;exact_package=chromium&amp;q=nigori&amp;l=29">NigoriStream-класс</a>, который реализует своеобразный concat строк через &lt;&lt;. Но мы не в C++, да и множественной записи в поток нам не нужно, достаточно просто&nbsp;объединить&nbsp;две строки вроде concatNigori:@"localhost" withString:@"dummy". Далее переходим к&nbsp;<a href="http://code.google.com/searchframe#OAMlx_jo-ck/src/sync/util/nigori.cc&amp;exact_package=chromium&amp;q=nigori&amp;l=68">формированию ключей</a>&nbsp;помощью алгоритма&nbsp;<a href="http://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a>. Для начала нам нужно сформировать&nbsp;<a href="http://code.google.com/searchframe#OAMlx_jo-ck/src/sync/util/nigori.cc&amp;exact_package=chromium&amp;q=nigori&amp;l=74">sUser</a>&nbsp;ключ. Он генерируется с HMAC SHA1 хешированием нашей конкат строки на месте псевдорандомной функции, паролем шифрования, и другими параметрами из&nbsp;<a href="http://code.google.com/searchframe#OAMlx_jo-ck/src/sync/util/nigori.h&amp;exact_package=chromium&amp;q=nigori&amp;ct=rc&amp;cd=1&amp;sq=">nigori.h</a>&nbsp;(длинна ключа 128 бит и количество итераций равное 1001). Тут возникает первая сложность, наша конкат строка создается следующим образом: NigoriStream salt_password &lt;&lt; username &lt;&lt; hostname. А вот со значениями переменных username и hostname&nbsp;небольшая&nbsp;проблема. Насколько я понял, в Google решили сделать их статичными localhost и dummy, упоминания об этом я нашел в коде юниттестов (что не показательно) и&nbsp;<a href="http://code.google.com/searchframe#OAMlx_jo-ck/src/sync/internal_api/sync_manager.cc&amp;exact_package=chromium&amp;q=dummy%20sync&amp;l=1280">тут</a>. Полученный salt (который мы переводим в строковой формат с помощью&nbsp;<a href="http://code.google.com/searchframe#OAMlx_jo-ck/src/crypto/symmetric_key_nss.cc&amp;exact_package=chromium&amp;q=GetRawKey&amp;l=111">GetRawKey</a>&nbsp;метода) мы будем использовать при генерации следующих ключей&nbsp;<a href="http://code.google.com/searchframe#OAMlx_jo-ck/src/sync/util/nigori.cc&amp;exact_package=chromium&amp;q=nigori&amp;l=87">kUser</a>&nbsp;(128 бит, 1002 цикла итерации),&nbsp;<a href="http://code.google.com/searchframe#OAMlx_jo-ck/src/sync/util/nigori.cc&amp;exact_package=chromium&amp;q=nigori&amp;l=91">kEnc</a>&nbsp;(128 бит, 1003 цикла итерации),&nbsp;<a href="http://code.google.com/searchframe#OAMlx_jo-ck/src/sync/util/nigori.cc&amp;exact_package=chromium&amp;q=nigori&amp;l=96">kMac</a>&nbsp;(128 бит, 1004 цикла итерации). В качестве псевдослучайной функции&nbsp;тут используется, насколько я понял, AES128. Теперь переходим непосредственно к нашей зашифрованной строке. Прежде всего, нам нужно&nbsp;<a href="http://code.google.com/searchframe#OAMlx_jo-ck/src/sync/util/nigori.cc&amp;exact_package=chromium&amp;q=nigori&amp;l=202">декодировать ее</a>&nbsp;из base64 в строку. Тут у меня возникает проблема #2, мы не знаем кодировки. Подозреваю, что это конечно же не ASCII, методом перебора (StringUsingEncoding для NSData) получилось установить, что строка декодируется лишь в UTF16 (я без понятия, нужно выбирать big или little endian). Далее&nbsp;<a href="http://code.google.com/searchframe#OAMlx_jo-ck/src/sync/util/nigori.cc&amp;exact_package=chromium&amp;q=nigori&amp;l=208">нарезаем</a>&nbsp;полученную строку на куски. Первые 16 байт - IV, последние 32 байта - hash, все, что между ними - наша зашифрованная строка. До расшифровки нам еще далеко, сначала нужно убедиться в том, что строка была зашифрована именно нашим паролем. Сравниваем наши последние 32 байта в виде hash строки с&nbsp;HMAC SHA256 хешсумой нашего kMac. В случае совпадения&nbsp;<a href="http://code.google.com/searchframe#OAMlx_jo-ck/src/sync/util/nigori.cc&amp;exact_package=chromium&amp;q=nigori&amp;l=235">инициализируем</a>&nbsp;AES CBC декриптор ключем kEnc и теми первыми 16 байтами IV. Этим декриптором расшифровываем строку и все.</div>
<div style="font-weight: normal;">
	&nbsp;</div>
<div style="font-weight: normal;">
	Пиздец, да. Непонятно, зачем такая паранойя, когда на конечной машине все пароли хранятся в sqlite базе данных без шифрования вообще. Я пытался собрать nigori.cc в static lib, но потерпел неудачу - необходимые зависимости просто отсутствовали. Возможно, есть вероятность собрать OpenSSL, а не NSS версию, под iOS это должно работать, но у меня просто не хватает ума. Желающие помочь приглашаются в скайп <a href="skype:orl-light?chat">orl-light</a> или в почту <a href="mailto:vladimir@smirnov.im">vladimir@smirnov.im</a>, где я с удовольствием расскажу вам все детали. Такой день.</div>
