![Теория изоляции и лимитирования процессов в linux userspace][header]

   [header]: /static/media/blog/processes-isolation/header.jpg

Этот пост задумывался пояснительными комментариями к листингу готовой программы, но меня почему-то в самый последний момент попросили удалить репозитарий из гитхаба, хотя открытость кода была оговорена заранее. Вот так теория и практика в заголовке статьи превратилась просто в теорию. Впрочем, я постараюсь достаточно детально рассказать о двух основных способах изоляции и лимитирования исполняемого процесса: basic, который не требует особых знаний, пересборки ядра, а необходимый функционал уже присутствует во всех современных дистрибутивах и advanced. 

Передо мной была поставлена следующая задача - написать быструю и построенную не на инструментах аппаратной или программной виртуализации среду запуска потенциально небезопасного пользовательского кода. Чтобы вам стало понятней, можете взглянуть на [Codepad][2] или [Ideone][3] - самые обычные пастебины, позволяющие собирать и выполнять написанный неизвестным Василием код, возвращая стандартный вывод процесса. Подобные задачи - не мое профильное направление, поэтому прошу меня простить, если я вдруг кое-где ошибусь в теории или буду говорить откровенные глупости.

   [2]: http://codepad.org/
   [3]: http://ideone.com/

Прежде всего, существующие решения конечно же есть. Я не буду сейчас перечислять все наколенные поделки в этой области, большинство из них написаны для своей конкретной задачи и нам не подходят. Безусловно, работающую систему можно построить на основе SELinux или AppArmor, оба проекта имеют базовую поддержку сэндбоксинга, пусть и находящуюся в состоянии "в ранней разработке" уже очень долго время. Останавливаться на этой тематике мы не будем, нас интересует свое собственное решение, информацию о песочнице в SELinux можно почитать в [ЖЖ][4] разработчика. Про AppArmor [aa-sandbox][5] тоже ничего сказать не могу, разве что синтаксис конфигурационных файлов понятней красноглазого селинукса.

   [4]: http://danwalsh.livejournal.com/28545.html
   [5]: http://wiki.apparmor.net/index.php/AppArmorSandboxing

Писать мы будем на сишечке. Почему, я думаю, объяснять не нужно. Почти все, что мы будем использовать, уже есть в ядре и libc. Основной алгоритм работы состоит в следующем: мы запускаем свой сэндбокс, который форкает небезопасный процесс, загоняет его в песочницу и выполняет, возвращая stdout. Делается это элементарно с помощью [clone()][6] или [fork()][7] с дальнейшим запуском через [execve()][8]. Для нас предпочтительным способом является использование clone(), который позволяет детально указать контекст родителя, которым мы будем делиться с дочерним процессом. Подробнее о различиях этих двух системных вызовов можно почитать [тут][9], например. Подобного эффекта можно добиться и с fork-ом, если вам так удобней, используя [unshare()][10]. В частности, для изоляции процесса нам необходимы следующие [битмаски][6] CLONE_NEWIPC, CLONE_NEWNET (самый простой способ отрезать исполняемый процесс от сети, можно еще воспользоваться iptables c ipt_owner), CLONE_NEWNS (это нам понадобится чуть ниже, когда мы дойдем до cgroups), CLONE_NEWPID, SIGCHLD (иначе [wait()][11] не будет получать сигналы от дочернего процесса). Чтобы было более менее понятно, я набросал небольшой [шаблон][12]. Код простой, но мы добились желаемого. Прежде всего мы загнали процесс в отдельные [Network][13], [Mount][14], [IPC][15] и [PID][16] неймспейсы и примитивно ограничили максимальное реальное время исполнения с помощью [alarm()][17] и соответствующего обработчика SIGALRM, убивающего дочерний процесс. Обращаю ваше внимание, что CLONE_NEWPID, который лишает нашу песочницу возможности посылать [kill()][18] или [ptrace()][19] процессам вне изолированного окружения, доступен в ядре начиная с 2.6.24, которое должно быть собрано с опцией CONFIG_PID_NS. Вы можете использовать [следующий код][20] для проверки его доступности, либо же cat /boot/config-`uname -r` | grep CONFIG_PID_NS.

   [6]: http://www.kernel.org/doc/man-pages/online/pages/man2/clone.2.html
   [7]: http://www.kernel.org/doc/man-pages/online/pages/man2/fork.2.html
   [8]: http://www.kernel.org/doc/man-pages/online/pages/man2/execve.2.html
   [9]: http://stackoverflow.com/questions/4856255/the-difference-between-fork-vfork-exec-and-clone
   [10]: http://www.kernel.org/doc/man-pages/online/pages/man2/unshare.2.html
   [11]: http://www.kernel.org/doc/man-pages/online/pages/man2/wait.2.html
   [12]: https://gist.github.com/4016027
   [13]: http://lwn.net/Articles/219794/
   [14]: http://www.ibm.com/developerworks/linux/library/l-mount-namespaces/index.html
   [15]: http://menehune.opt.wfu.edu/Kokua/More_SGI/007-2478-008/sgi_html/ch02.html
   [16]: http://lwn.net/Articles/259217/
   [17]: http://linux.die.net/man/2/alarm
   [18]: http://www.kernel.org/doc/man-pages/online/pages/man2/kill.2.html
   [19]: http://www.kernel.org/doc/man-pages/online/pages/man2/ptrace.2.html
   [20]: http://code.google.com/p/chromium/wiki/LinuxPidNamespaceSupport

Ограничив базовый доступ, можно начинать ограничивать выделяемые ресурсы. Делается это с помощью вызова [setrlimit()][21]. В нашем случае нас будут интересовать значения RLIMIT_AS (лимит размера адресного пространства процесса в байтах), RLIMIT_CPU (лимит [CPU time][22] в секундах), RLIMIT_FSIZE (максимальный размер создаваемого процессом файла в байтах, защита от дурака, любящего что-то вроде dd if=/dev/zero of=becausefuckyouthatswhy bs=1g count=10000), RLIMIT_NICE (максимальное значение для [nice()][23] и [setpriority()][24], одного nice() перед exec() будет недостаточно, без этого лимита процесс всегда может поднять значение), RLIMIT_NOFILE (максимальное количество файловых дескрипторов, которое может открыть процесс), RLIMIT_NPROC (единственный лимит, который должен устанавливаться непосредственно после [setuid()][25], ограничивает максимальное количество процессов, создаваемых для UID вызывающего процесса).

   [21]: http://www.kernel.org/doc/man-pages/online/pages/man2/getrlimit.2.html
   [22]: http://www.gnu.org/software/libc/manual/html_node/Processor-And-CPU-Time.html#Processor-And-CPU-Time
   [23]: http://www.kernel.org/doc/man-pages/online/pages/man2/nice.2.html
   [24]: http://www.kernel.org/doc/man-pages/online/pages/man2/setpriority.2.html
   [25]: http://www.kernel.org/doc/man-pages/online/pages/man2/setuid.2.html

К более гибкому лимитированию мы еще вернемся, когда будем говорить о cgroups. Наш процесс уже изолирован от прямого вмешательства в систему, осталось лишь ограничить доступ к файловой системе. Делать мы это будем с помощью старого доброго [chroot()][26]. За годы работы с серверами я выработал правило запуска сомнительных и потенциально небезопасных приложений вроде PHP и прочего говна исключительно в отдельном root environment, созданном с помощью [debootstrap][27] либо любого пакета в зависимости от целевой ОС. В последнее время, все чаще пользуюсь более надежным и безопасным [LXC][28] но разговор о другом. После вызова chroot() должен обязательно следовать вызов setuid() чтобы не допустить возможности [побега][29] из тюрьмы. В нашем случае будет идеальным использование несуществующего рандомного UID-а наподобие int new_uid = MAX_EXISTING_UID + random_in_range (1, 99). Вот и все, правильно выставленный chmod() на рабочую директорию процесса в сочетании со всем вышенаписанным гарантирует достаточную изоляцию гаденыша в песочнице. Я повторюсь - достаточную, но не идеальную, данный способ не спасает от privilege escalation атак или прочих уязвимостей ядра, связанных с memory allocation and management, например. 

   [26]: http://www.kernel.org/doc/man-pages/online/pages/man2/chroot.2.html
   [27]: http://wiki.debian.org/Debootstrap
   [28]: http://lxc.sourceforge.net/
   [29]: http://www.bpfh.net/simes/computing/chroot-break.html

Говоря об advanced методах лимитирования и изоляции, мы рассмотрим примеры использования cgroups, ptrace, seccomp и seccomp-filters. 

Cgroups или Control Groups - механизм объединения процессов в группы с определенным поведением и лимитами. Данный функционал был написан инженерами Google, включен в мейнлайн ядра начиная с версии 2.6.24 и имеет достаточно хорошую [документацию][30]. А еще я нашел очень понятный [пост][31] на русском языке по этой тематике и разжеванное описание в [документации][32] openSUSE. Как всегда, проверяем необходимые нам опции с помощью zcat /proc/config.gz или cat /boot/config-`uname -r` | grep CGROUP. Cgroups имеют свое API, но мы будем использовать более простой способ, основанный на cgroup sysfs. Прежде всего, нужно разобраться в иерархии этого модуля. Корень для cgroups (обычно /sys/fs/cgroup/, но тут никакого правила нет) - обычная директория, можете подмонтировать ее как tmpfs. В корневую директорию монтируются подсистемы cpuacct, cpuset, devices, freezer, memory и прочие. Весь список можно посмотреть в документации. Примонтированная подсистема имеет влияние на все процессы данного UID, список PID-ов можно посмотреть в /sys/fs/cgroup/devices/tasks, как пример. Изменяемые параметры подсистемы - файлы, доступные как для чтения, так и на запись. Отдельные группы - простые папки в директории подсистемы. 

   [30]: http://www.kernel.org/doc/Documentation/cgroups/
   [31]: http://programmersnook.blogspot.com/2011/04/cgroups.html
   [32]: http://doc.opensuse.org/documentation/html/openSUSE/opensuse-tuning/cha.tuning.cgroups.html

Наверное, я объясняю слишком топорно. Чтобы было понятней, я написал небольшой [bash скрипт][33] показывающий основы работы. Если подобный способ взаимодействия вам кажется не достаточно низкоуровневым, можете обратить внимание на [libcg][34] - абстракции вокруг control groups API, правда документация там мягко говоря говнистая, а нормального примера использования так и не удалось найти. Кстати, Linux Containers основаны именно на базе cgroups.

   [33]: https://gist.github.com/4016674
   [34]: http://libcg.sourceforge.net/

Казалось бы, чего еще бояться и пытаться изолировать. Тут нужно вспомнить теорию организации и функционирования современных операционных систем, использующих system calls для взаимодействия с ядром ОС. Это если совсем грубо, чуть детальнее с вопросом можно ознакомиться в на удивление неплохой [статье в википедии][35]. К примеру, мы знаем, что /bin/cat используется следующие syscall-ы для вывода содержимого файла: mmap для выделения памяти, fstat для проверки существования файла и прав доступа к нему, open для открытия файлового дескриптора, read для чтения, write для вывода содержимого текста в stdout и close для закрытия всех открытых ранее дескрипторов. И мы уверены, что /bin/cat уж точно не должен вызывать execv(), bind() или там при cat test.txt пытаться открыть /etc/shadow. Бороться с этим можно медленным, но проверенным ptrace(); быстрым, но сложным seccomp; либо же оптимальным, но присутствующим только в последних версиях ядра, seccomp-filters.

   [35]: http://en.wikipedia.org/wiki/System_call

Как уже было сказано выше, ptrace - способ присутствующий почти на всех Linux системах, но заметно замедляющий скорость исполнения. Все это связано со спецификой его работы и применения. Ptrace используется исключительно для отладки, где не нужна большая скорость - это раз, во-вторых после каждого системного вызова дочерний процесс приостанавливается, а мы обрабатываем SIGTRAP сигнал, получаем int код системного вызова, его параметры, решаем, что с этим делать и посылаем PTRACE_CONT. Разумеется, это будет работать более чем медленно. Пример кода я приводить не буду, можете просто посмотреть исходный код [strace][36]. Существуют десятки абстракций вокруг ptrace, я же могу посоветовать [pinktrace][37] - хорошие доки и простой функционал декодирования аргументов основных системных вызовов из коробки.

   [36]: http://strace.git.sourceforge.net/git/gitweb.cgi?p=strace/strace;a=tree
   [37]: http://dev.exherbo.org/~alip/pinktrace/

Seccomp был добавлен в ядро Linux с версии 2.6.12 и компилируется с опцией CONFIG_SECCOMP в .config. По сути, его действие сводится к посылке SIGKILL-у процессу при попытке выполнить любые syscall-ы кроме exit(), read(), write(), sigreturn(). При этом, read и write могут использовать исключительно дескрипторы, которые уже были открыты родительским процессом, что нам изначально это не подходит - мы не поделились этим контекстом, не передав CLONE_FILES в clone flags. Именно seccomp [используют][38] разработчики Google Chrome для создания песочницы процессов браузера. При этом, все запрещенные системные вызовы могут быть реализованы в коде. К примеру, вы можете написать свой или использовать сторонний [memory manager][39] и так далее. Пример реализации sandbox на основе seccomp в Chromium можете посмотреть по ссылке чуть выше либо же в проекте [seccomp-nurse][40]. Это безопасный и достаточно быстрый способ изоляции, но слишком сложный для реализации.

   [38]: http://code.google.com/p/seccompsandbox/
   [39]: http://eli.thegreenplace.net/2008/10/17/memmgr-a-fixed-pool-memory-allocator/
   [40]: https://github.com/nbareil/seccomp-nurse

Но есть и адекватное усредненное решение под названием seccomp-filters, позволяющее обозначить blacklist или whitelist системных вызовов и поведение программы при совпадении вызова и, что очень важно, его параметров с первым либо же со вторым списком. Seccomp filters или seccomp mode 2 появились в ядре в версии 3.5, которое должно быть собрано с параметром CONFIG_SECCOMP_FILTER. Использовать советую не напрямую через [prctl()][41], а с помощью библиотеки [libseccomp][42]. Каждый метод имеет свой детальный man 2, а в интернетах можно найти [описание][43] и немного устаревший [пример использования][44].

   [41]: http://www.kernel.org/doc/man-pages/online/pages/man2/prctl.2.html
   [42]: http://sourceforge.net/projects/libseccomp/
   [43]: https://lwn.net/Articles/494252/
   [44]: http://lwn.net/Articles/491308/
