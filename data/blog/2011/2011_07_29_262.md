Сегодня мы поговорим о разработке сервиса создания скриншотов сайтов. Так получилось, что я занимался этим для одного интранетовского проекта и, получив&nbsp;благословение&nbsp;и разрешение добродушного заказчика&nbsp;из лесистой Финляндии&nbsp;c аватаркой чрезвычайной усатости, публикую тут подробное описание процесса и технологий, возможно, это кого-то заинтересует. Использовать мы будем следущий инструментарий:&nbsp;<a href="http://nodejs.org/" title="" >NodeJS</a>, <a href="http://socket.io" title="" >SocketIO</a>, <a href="http://xvnc.sourceforge.net/DxdPIwjDA" title="" >Xvnc</a>, <a href="http://en.wikipedia.org/wiki/Xwd" title="" >xwd</a>, <a href="http://www.chromium.org/" title="" >Chromium</a> и еще кучу всего другого. Вкратце постановка задачи выглядела подобным образом: нужен API, возвращающий скриншот сайта в PNG, проект сам по себе - внутренний сервис компании юзабилити тестирования. Только нужно было управиться без всех этих хитрожопых и кривых command-line конверсий по типу khtml2png, а грабить настоящий живой вывод современных браузеров. Я, почесав репу, решил выделить три уровня разработки и автоматизации: serverside, middleware и конечно же clientside, которые я вам сейчас и опишу, дорогие мои.<p>Начнем с самого глубокого серверсайда. В распоряжении&nbsp;имелся&nbsp;старенький слабенький сервачок с ненавистным CentOS-ом, ну делать было нечего. Прежде всего, нужно понять, что без иксов нам абсолютно никак не обойтись. Они нужны для виртуальных дисплеев, куда мы будем высаживать наши браузеры. Варианта два: мы можем использовать xorg-x11-server-Xvfb либо же vncserver, который представляет собой perl обертку вокруг Xvnc. Я советую остановиться на втором варианте преимущественно по причине меньшего количества dependencies, возможности удобного удаленного подключения для настройки того же браузера и&nbsp;отсутствия&nbsp;проблем с битностью цвета. К тому же, на старике-центосе Xvfb почему-то постоянно отваливался, а ядро было собрано без поддержки framebuffer, поэтому устройство /dev/fb[0-9] отсутствовало, сводя на нет все преимущества утилит fbdump и fbgrab. После установки vncserver, протестируем его работоспособность, вызвав&nbsp;<span class="Apple-style-span" style="font-style: italic;">vncserver :11 -geometry 1920х1200 -depth 24</span>. У вас спросят пароль при первом запуске и, если все прошло без ошибок, то вы счастливчик. Иксы на виртуальном дисплее localhost:11 у вас уже есть. Можете рассказать это своему environment (ненавижу слово "окружение") c помощью <span class="Apple-style-span" style="font-style: italic;">export DISPLAY=:11. </span>А еще вы можете запустить xterm и сконектиться через VNC клиент (для виндовса есть отличный бесплатный от <a href="http://www.realvnc.com/" title="" >RealVNC</a>) и в очередной раз убедиться, что все работает. Теперь нам нужно как-то воровать экран и сохранять его в изображение. В интернетах советуют использовать утилиту import, входящую в набор ImageMagic, но это как перевозить две горошины на грузовом самолете. Вместо нее мы будем использовать xwd из&nbsp;xorg-x11-apps для снятия слепка с виртуального дисплея, и&nbsp;xwdtopnm плюс pnmtopng из&nbsp;netpbm-progs для конвертации его в PNG формат. Тут все еще проще, для получения скриншота вам нужно просто выполнить&nbsp;<span class="Apple-style-span" style="font-style: italic;">xwd -root -display localhost:11 | xwdtopnm 2&gt;/dev/null | pnmtopng &gt; screenshot.png</span>. Большая часть серверной магии окончена, осталось сделать небольшой скрипт автоматизации и защиты от дураков. Оговорюсь сразу, что процесс генерации сриншотов будет последователен на основе очереди задач, никакого распараллеливания. О причинах этого мы поговорим чуточку позже. После установки Хромиума, что для ебучего CentOS-а, который сыпется пылью из всех щелей, тоже нихуя не тривиальная задача, мы сделаем <a href="http://commondatastorage.googleapis.com/files.mindcollapse.com/etc/screenshooter/makescrsht.sh" title="" >небольшой скрипт</a> для облегчения рутины создания скриншотов. Хромиум запускается в инкогнито режиме в фоне, мы ждем открытия страницы 6 секунд (для многих страниц этого времени не хватает, но для тестов сойдет), снимаем скришот и жестко тушим все открытые процессы. Если вам не нужны элементы оформления браузера аля адресная строка или панель табов, то можете добавить ключ --kiosk при запуске хрома. Все пропадет, останется лишь окно с отрендериной страницей, но это выглядит как-то менее эстетично ;). Таким образом, мы собрали все необходимое для создания скриншотов, осталось написать обертку и обертку над оберткой. Пару слов про&nbsp;безопасность: создайте отдельного пользователя из-под которого будете запускать браузер и иксы, отключите все плагины на внутренней странице about:plugins.&nbsp;Клиентская&nbsp;и серверная валидация&nbsp;ссылок&nbsp;в добавок к жесткому ограничению времени исполнения (у нас это 6 секунд) защищает от умников, которые мечтают о stack overflow и arbitrary code execution&nbsp;или пытаются банально загрузить html файл размером с пару гигабайт. От запуска нескольких инстансов браузера для многопоточной генерации пришлось отказаться по этой же самой причине. И да, все настройки хромиума хранятся в JSON формате в файле <span class="Apple-style-span" style="font-style: italic;">~/.config/chromium/Default/Preferences</span>, изменить вам придется параметры размеров окна, потому что даже с ключом&nbsp;--start-maximized у браузера развернуть окно на весь виртуальный экран почему-то не получается.</p><p>Часть вторая - middleware или, другими словами, прослойка между сервером-клиентом и своеобразный примитивный менеджер задач. Писать мы ее будем на NodeJS и SocketIO, оба решения мне полюбились event-based моделью. В стандартный набор ноде входит функция spawn объекта child_process для асинхронного запуска дочерних процессов и получения их stdout потоков, которая и будет работать с нашим небольшим bash скриптом. Для создания последовательной модели исполнения, нам нужен какой-то неблокирующий алгоритм task queue и именно поэтому нам не подходит метод Array.forEach. Я, признаться, не стал ебать себе мозг академическими решениями и просто сделал рекурсивную функцию, которая банально вызывала Array.push при добавлении новой задачи и Array.shift при завершении выполнения и переходе на новый цикл итерации с проверкой блокирующей переменной. Решение не идеальное и при больших нагрузках могут возникать проблемы с выпадающими из стека заданиями, но никто больших нагрузок и не ждет - идеальная отговорка для лентяя, который поленился сделать асинхронную модель обработки с помощью&nbsp;setInterval. Чтобы не быть голословным - вот вам <a href="http://commondatastorage.googleapis.com/files.mindcollapse.com/etc/screenshooter/process.js" title="" >код прослойки</a>. Судя по коллекции сохраненных скриншотов, некоторые куллхакеры, думающие, что, выполнив в консоле isURL = function() {return true;}, они обойдут все проверки и удалят мне /etc/passwd, соснули хуйцов и посмотрели веселые картинки на сайте gay.ru. Кекеке!</p><p>Последний и самый верхний уровень - clientside не представляет собой ничего особо интересного. Хочу лишь заметить, что при всех преимуществах охуительнейшей библиотеки SocketIO, у нее нету нормальной внятной документации или хотя бы описания API. Лично мне найти не удалось, на гитхабе только описание в примерах, но это не удобно и противоречит законам мироздания. Справедливости ради скажу, что все, описанное мной в этом посте, пахнет влагой и сыростью. Нету ни обработок исключений, ни проверок результата генерации, ни нормальной валидации ссылок, но я лишь даю болванку, а ее обтачивание - дело дорчитателей, которым это необходимо.</p><p>Куда ж мы без живых примеров? Никто в наше время тексту не верит. Пришлось перенести все на свой старенький сервачок в далекой Фрицландии, сделать симпатичную обертку на скорую руку и теперь вы можете проверить работу теории на практике в&nbsp;разрастающейся&nbsp;секретной&nbsp;экспериментальной&nbsp;лаборатории интернетовских опытов имени Коли Цискаридзе. <a href="http://lab.mindcollapse.com/ScreenShooter/" title="" >Ссылка на ScreenShooter</a>, который старательной описывался в этой статье,&nbsp;работает до последнего посетителя. В качестве бонуса всем, кто дочитал достаточно сложную для формата блога&nbsp;статью, я дарю самодельный <a href="http://lab.mindcollapse.com/SeoRaskrutka/" title="" >уникальный инструмент</a> по раскрутке вашего сайта, известный подписчикам моего <a href="http://www.twitter.com/middlesizetit" title="" >твиттера</a> и <a href="https://plus.google.com/110904145311662435301" title="" >гуглоплюса</a>. А если серьезно, спасибо всем, кто активно плюсует гуглокнопкой мои посты. Это достаточно приятно и позволяет понять направление дальнейшего развития тематик. Продолжайте в том же духе, нажимайте +1, у меня еще много разнообразных интересностей в черновиках.</p>